#pragma once

#include "lev.h"
#include "utils.h"

#include <cstdint>
#include <cmath>

namespace PSX
{
	static constexpr size_t MAX_NUM_PLAYERS = 4;

	struct Vec3b
	{
		int8_t x;
		int8_t y;
		int8_t z;
  };

	struct Vec3
	{
		int16_t x;
		int16_t y;
		int16_t z;
	};

	struct Color
	{
		uint32_t r : 8;
		uint32_t g : 8;
		uint32_t b : 8;
		uint32_t a : 8;
	};

	struct Spawn
	{
		PSX::Vec3 pos;
		PSX::Vec3 rot;
	};

	struct BoundingBox
	{
		PSX::Vec3 min;
		PSX::Vec3 max;
	};

	struct VRMHeader
	{
		uint32_t size;
		uint32_t magic;
		uint32_t flags;
		uint32_t len;
		uint16_t x;
		uint16_t y;
		uint16_t width;
		uint16_t height;
	};

	struct BlendMode
	{
		static constexpr uint16_t HALF_TRANSPARENT = 0;
		static constexpr uint16_t ADDITIVE = 1;
		static constexpr uint16_t SUBTRACTIVE = 2;
		static constexpr uint16_t ADDITIVE_TRANSLUCENT = 3;
	};

	union Texpage
	{
		struct
		{
			uint16_t x : 4; /* x * 64 */
			uint16_t y : 1; /* y * 256 */
			uint16_t blendMode : 2; /* (0=B/2+F/2, 1=B+F, 2=B-F, 3=B+F/4) */
			uint16_t texpageColors : 2; /* (0=4bit, 1=8bit, 2=15bit, 3=Reserved) */
			uint16_t unused : 2;
			uint16_t y_VRAM_EXP : 1; /* ununsed in retail */
			uint16_t unused2 : 2;
			uint16_t nop : 2;
		};
		uint16_t self;
	};

	union CLUT
	{
		struct
		{
			uint16_t x : 6; /* X/16  (ie. in 16-halfword steps) */
			uint16_t y : 9; /* 0-511 (ie. in 1-line steps) */
			uint16_t nop : 1; /* Should be 0 */
		};
		uint16_t self;
	};

	struct TextureLayout
	{
		uint8_t u0;
		uint8_t v0;
		CLUT clut;
		uint8_t u1;
		uint8_t v1;
		Texpage texPage;
		uint8_t u2;
		uint8_t v2;
		uint8_t u3;
		uint8_t v3;

		inline bool operator==(const TextureLayout& layout) const
		{
			return u0 == layout.u0 && v0 == layout.v0 &&
						 u1 == layout.u1 && v1 == layout.v1 &&
						 u2 == layout.u2 && v2 == layout.v2 &&
						 u3 == layout.u3 && v3 == layout.v3 &&
						 clut.self == layout.clut.self &&
						 texPage.self == layout.texPage.self;
		}
	};

	struct TextureGroup
	{
		TextureLayout far;
		TextureLayout middle;
		TextureLayout near;
		TextureLayout mosaic;
	};

	struct AnimTex
	{
		uint32_t offActiveFrame;
		uint16_t frameCount;
		int16_t startAtFrame;
		int16_t frameDuration;
		uint16_t frameIndex;
	};

	struct ColorGradient
	{
		int16_t posFrom;
		int16_t posTo;
		PSX::Color colorFrom;
		PSX::Color colorTo;
	};

	struct Stars
	{
		uint16_t numStars;
		uint16_t spread;
		uint16_t seed;
		uint16_t zDepth;
	};

	struct Weather
	{
		uint32_t numParticles; // 0x0
		uint16_t maxParticles; // 0x4
		int16_t vanishRate; // 0x6
		uint8_t unk_0x8[0x10]; // 0x8
		PSX::Vec3 camPos; // 0x18
		uint16_t unk_0x1E; // 0x1E - maybe padding
		PSX::Color top; // 0x20
		PSX::Color bottom; // 0x24
		uint32_t renderMode[2]; // 0x28
	};

	struct LevHeader
	{
		uint32_t offMeshInfo; // 0x0
		uint32_t offSkybox; // 0x4
		uint32_t offAnimTex; // 0x8
		uint32_t numInstances; // 0xC ////////////0x42
		uint32_t offInstances; // 0x10 ////////////0x690 ~~~~~PATCH_ME~~~~~ //ptr to an actual instdef
		uint32_t numModels; // 0x14 ////////////0xF
		uint32_t offModels; // 0x18 ////////////0x1710 ~~~~~PATCH_ME~~~~~ //ptr to an array of ptrs to models
		uint32_t offUnk_0x1C; // 0x1C //ptr to a region of 160 0xff's
		uint32_t offUnk_0x20; // 0x20 //ptr to a region of 68 0xff's
		uint32_t offModelInstances; // 0x24 ////////////0x5A90C ~~~~~PATCH_ME~~~~~ //ptr to an array of pts to instdefs
		uint32_t offUnk_0x28; // 0x28
		uint32_t null_0x2C; // 0x2C
		uint32_t null_0x30; // 0x30
		uint32_t numWaterVertices; // 0x34
		uint32_t offWaterVertices; // 0x38
		uint32_t offIconsLookup; // 0x3C
		uint32_t offIcons; // 0x40
		uint32_t offEnvironmentMap; // 0x44
		PSX::ColorGradient skyGradient[NUM_GRADIENT]; // 0x48
		PSX::Spawn driverSpawn[NUM_DRIVERS]; // 0x6C
		uint32_t offUnk_0xCC; // 0xCC //ptr to a region of 60 0xff's
		uint32_t offUnk_0xD0; // 0xD0 //ptr to a region of 44 0xff's
		uint32_t offLowTexArray; // 0xD4
		PSX::Color clear; // 0xD8
		uint32_t config; // 0xDC
		uint32_t offBuildStart; // 0xE0
		uint32_t offBuildEnd; // 0xE4
		uint32_t offBuildType; // 0xE8
		uint8_t unk_0xEC[0x18]; // 0xEC // 0x18 0x0's
		PSX::Weather weather; // 0x104
		uint32_t offExtra; // 0x134
		uint32_t numSpawnType_2; // 0x138
		uint32_t offSpawnType_2; // 0x13C
		uint32_t numSpawnType_2_posRot; // 0x140
		uint32_t offSpawnType_2_posRot; // 0x144
		uint32_t numCheckpointNodes; // 0x148
		uint32_t offCheckpointNodes; // 0x14C
		uint8_t unk_0x150[0x10]; // 0x150 // 0x10 0x0's
		PSX::Color gradientClear[3]; // 0x160
		uint32_t unk_0x16C; // 0x16C // 0x0
		uint32_t unk_0x170; // 0x170 //ptr to a region of unknown length (probably 0x4) of 0xff's
		uint32_t numSCVertices; // 0x174
		uint32_t offSCVertices; // 0x178
		Stars stars; // 0x17C
		uint8_t splitLines[4]; // 0x184
		uint32_t offLevNavTable; // 0x188
		uint32_t unk_0x18C; // 0x18C //0x0
		uint32_t offVisMem; // 0x190
		uint8_t footer[0x60]; // 0x194
	};

	struct InstDef
	{
		// 0
		char name[0x10]; //cactus_saguro#2

		// 0x10 (0x18 - 8)
		uint32_t offModel; //offset 0x00064534 ~~~~~PATCH_ME~~~~~ (struct Model*)

		// 0x14 (0x1c - 8)
		Vec3 scale; //0x1000 0x1000 0x1000

		int16_t maybeScaleMaybePadding; //0x0

		// 0x1c (0x24 - 8)
		uint32_t colorRGBA; //0x0

		// 0x20 (0x28 - 8)
		uint32_t flags; //0x0000000B

		uint32_t unk24; //0x0
		uint32_t unk28; //0x0

		// 0x2c
		uint32_t offInstance; //0x0 (filled in at runtime)

		// 0x30
		Vec3 pos; //0x0C2D 0x0900 0xED86

		// 0x36
		Vec3 rot; //0x0000 0xFF94 0x0000

		// 0x3c
		int32_t modelID; //0xFFFFFFFF

		// 0x40 -- struct size
	};

	struct Model
	{
		// name of model group
		// "oxide" for example
		// 0x0
		char name[0x10]; //cactus_saguro

		// index of 2160 array
		// 0x10
		int16_t id; //0xFFFF

		// 0x12
		uint16_t numHeaders; //0x0001

		// 0x14
		uint32_t offHeaders; //0x0006454C ~~~~~PATCH_ME~~~~~ (struct ModelHeader)
	};

	struct ModelHeader
	{
		// name of individual model LOD,
		// "oxide_hi" for example
		// 0x0
		char name[0x10]; //cactus_saguro_h

		// 0x10
		uint32_t unk1; //0x0

		// 0x14
		uint16_t maxDistanceLOD; //0x2000

		// 0x16
		// 0x0 - normal 3D model
		// 0x1 - always point north
		// 0x2 - always point to camera (warppad numbers)
		uint16_t flags; //0x0000

		// 0x18
		Vec3 scale; //0x271E 0x2B3B 0x0E5E

		int16_t maybeScaleMaybePadding; //0x0

		// 0x20
		uint32_t offCommandList; //0x000645AC ~~~~~PATCH_ME~~~~~

		// 0x24
		// null if there are animations
		uint32_t offFrameData; //0x0006470C ~~~~~PATCH_ME~~~~~ (struct ModelFrame)

		// 0x28
		uint32_t offTexLayout; // same as LEV ~~~~~PATCH_ME~~~~~ //0x000647AC

		// 0x2C
		uint32_t offColors; // CLUT = color lookup table ~~~~~PATCH_ME~~~~~ //0x000648CC

		// 0x30
		// same as anim->0x14
		uint32_t unk3; //0x0

		// 0x34
		uint32_t numAnimations; //0x0

		// 0x38
		uint32_t offAnimations; //0x0

		// 0x3C
		uint32_t offAnimtex; //0x0
	};

	//see https://github.com/CTR-tools/CTR-tools/blob/master/formats/txt_ctr.txt
	// Format: slndkv?? iiiiiiii ccccccct tttttttt (bits 31->0, MSB->LSB)
	// On little-endian (x86/x64), bitfields pack from bit 0 upward, so declare in REVERSE order:
	struct InstDrawCommand
	{
		union {
			uint32_t command;
			struct {
				uint32_t texCoordIndex : 9;                      // bits 0-8   (t: tex coord index, 0=no texture)
				uint32_t colorCoordIndex : 7;                    // bits 9-15  (c: color coord index)
				uint32_t stackWriteLocationIndex : 8;           // bits 16-23 (i: stack index)
				uint32_t unk2 : 1;                               // bit 24     (?: unknown)
				uint32_t unk1 : 1;                               // bit 25     (?: unknown)
				uint32_t readNextVertFromStackIndexFlag : 1;    // bit 26     (v: read from stack vs array)
				uint32_t colorFromScratchpadOrRamFlag : 1;      // bit 27     (k: scratchpad vs ram)
				uint32_t noBackfaceFlag : 1;                     // bit 28     (d: cull backface)
				uint32_t normalFlipFlag : 1;                     // bit 29     (n: flip normal)
				uint32_t swapFlag : 1;                           // bit 30     (l: swap 1st vertex)
				uint32_t resetFlag : 1;                          // bit 31     (s: new face block/reset)
			};
		};
	};

	struct ModelFrame
	{
		// origin
		Vec3 pos; //0xFF65 0x0000 0xFF7E
		int16_t maybePosMaybePadding; //0x0
		char unk16[16]; //sixteen 0x0
		int vertexOffset; // always 0x1C //0x0000001C

		//char verts[0];
	};

	struct MeshInfo
	{
		uint32_t numQuadblocks;
		uint32_t numVertices;
		uint32_t unk1;
		uint32_t offQuadblocks;
		uint32_t offVertices;
		uint32_t unk2;
		uint32_t offBSPNodes;
		uint32_t numBSPNodes;
	};

	/* TODO: Figure out what each value actually is for and properly name them */
	enum LevelExtra
	{
		MINIMAP = 0,
		SPAWN = 1, // what
		CAMERA_END_OF_RACE = 2,
		CAMERA_DEMO = 3,
		N_TROPY_GHOST = 4,
		N_OXIDE_GHOST = 5,
		CREDITS = 6, // what
		COUNT = 7,
	};

	struct LevelExtraHeader
	{
		uint32_t count;
		uint32_t offsets[LevelExtra::COUNT];
	};

	struct Vertex
	{
		PSX::Vec3 pos; // 0x0
		uint16_t flags; // 0x6
		PSX::Color colorHi; // 0x8
		PSX::Color colorLo; // 0xC
	};

	struct Quadblock
	{
		uint16_t index[NUM_VERTICES_QUADBLOCK]; // 0x0
		uint16_t flags; // 0x12
		uint32_t drawOrderLow; // 0x14
		uint32_t drawOrderHigh; // 0x18
		uint32_t offMidTextures[4]; // 0x1C
		PSX::BoundingBox bbox; // 0x2C
		uint8_t terrain; // 0x38
		uint8_t weatherIntensity; // 0x39
		uint8_t weatherVanishRate; // 0x3A
		int8_t speedImpact; // 0x3B
		uint16_t id; // 0x3C
		uint8_t checkpointIndex; // 0x3E
		uint8_t triNormalVecBitshift; // 0x3F
		uint32_t offLowTexture; // 0x40
		uint32_t offVisibleSet; // 0x44
		int16_t triNormalVecDividend[10]; // 0x48
	};

	struct Checkpoint
	{
		PSX::Vec3 pos;
		uint16_t distToFinish;
		uint8_t linkUp;
		uint8_t linkLeft;
		uint8_t linkDown;
		uint8_t linkRight;
	};

	struct BSPBranch
	{
		uint16_t flag;
		uint16_t id;
		PSX::BoundingBox bbox;
		PSX::Vec3 axis;
		int16_t unk1;
		uint16_t leftChild;
		uint16_t rightChild;
		uint16_t unk2;
		uint16_t unk3;
	};

	struct BSPLeaf
	{
		uint16_t flag; // 0x0
		uint16_t id; // 0x2
		PSX::BoundingBox bbox; // 0x4
		uint32_t unk1; // 0x10
		uint32_t offHitbox; // 0x14
		uint32_t numQuads; // 0x18
		uint32_t offQuads; // 0x1C
	};

	struct VisibleSet
	{
		uint32_t offVisibleBSPNodes;
		uint32_t offVisibleQuadblocks;
		uint32_t offVisibleInstances;
		uint32_t offVisibleExtra;

		inline bool operator==(const VisibleSet& v) const
		{
			return offVisibleBSPNodes == v.offVisibleBSPNodes &&
						 offVisibleQuadblocks == v.offVisibleQuadblocks &&
						 offVisibleInstances == v.offVisibleInstances &&
						 offVisibleExtra == v.offVisibleExtra;
		}
	};

	struct VisualMem
	{
		uint32_t offNodes[MAX_NUM_PLAYERS]; // 0x0
		uint32_t offQuads[MAX_NUM_PLAYERS]; // 0x4
		uint32_t offOcean[MAX_NUM_PLAYERS]; // 0x8
		uint32_t offScenery[MAX_NUM_PLAYERS]; // 0xC
		uint32_t offNodesSrc[MAX_NUM_PLAYERS]; // 0x10
		uint32_t offQuadsSrc[MAX_NUM_PLAYERS]; // 0x14
		uint32_t offOceanSrc[MAX_NUM_PLAYERS]; // 0x18
		uint32_t offScenerySrc[MAX_NUM_PLAYERS]; // 0x1C
		uint32_t offBSP[MAX_NUM_PLAYERS]; // 0x20
	};

	struct NavHeader
	{
		uint16_t magic;
		uint16_t numPoints;
		uint32_t posY;
		uint32_t offLastPoint;
		uint16_t physUnk[0x20];
	};
}

template<>
struct std::hash<PSX::TextureLayout>
{
	inline std::size_t operator()(const PSX::TextureLayout& key) const noexcept
	{
		uint32_t pos0 = key.u0 | (key.v0 << 8) | (key.u1 << 16) | (key.v1 << 24);
		uint32_t pos1 = key.u2 | (key.v2 << 8) | (key.u3 << 16) | (key.v3 << 24);
		uint32_t extra = key.clut.self | (key.texPage.self << 16);
		std::size_t seed = 0;
		HashCombine(seed, pos0);
		HashCombine(seed, pos1);
		HashCombine(seed, extra);
		return seed;
	}
};

template<>
struct std::hash<PSX::VisibleSet>
{
	inline std::size_t operator()(const PSX::VisibleSet& key) const noexcept
	{
		std::size_t seed = 0;
		HashCombine(seed, key.offVisibleBSPNodes);
		HashCombine(seed, key.offVisibleQuadblocks);
		HashCombine(seed, key.offVisibleInstances);
		HashCombine(seed, key.offVisibleExtra);
		return seed;
	}
};

static constexpr int16_t FP_ONE = 0x1000;
static constexpr int16_t FP_ONE_GEO = 64;
static constexpr int16_t FP_ONE_CP = 8;

static inline int16_t ConvertFloat(float x, int16_t one = FP_ONE) { return static_cast<int16_t>(std::round(x * static_cast<float>(one))); };
static inline int16_t ConvertAngle(float x) { return static_cast<int16_t>(std::round((x * static_cast<float>(FP_ONE)) / 360.0f)); }
static inline float ConvertFP(int16_t fp, int16_t one = FP_ONE) { return static_cast<float>(fp) / static_cast<float>(one); }
static inline float ConvertFPAngle(int16_t fp) { return (static_cast<float>(fp) * 360.0f) / static_cast<float>(FP_ONE); }

static inline PSX::Vec3 ConvertAngle(const Vec3& v)
{
	PSX::Vec3 out = {};
	out.x = ConvertAngle(v.x);
	out.y = ConvertAngle(v.y);
	out.z = ConvertAngle(v.z);
	return out;
}

static inline Vec3 ConvertPSXAngle(const PSX::Vec3& v)
{
	Vec3 out = {};
	out.x = ConvertFPAngle(v.x);
	out.y = ConvertFPAngle(v.y);
	out.z = ConvertFPAngle(v.z);
	return out;
}

static inline PSX::Vec3 ConvertVec3(const Vec3& v, int16_t one = FP_ONE)
{
	PSX::Vec3 out = {};
	out.x = ConvertFloat(v.x, one);
	out.y = ConvertFloat(v.y, one);
	out.z = ConvertFloat(v.z, one);
	return out;
}

static inline Vec3 ConvertPSXVec3(const PSX::Vec3& v, int16_t one = FP_ONE)
{
	Vec3 out = {};
	out.x = ConvertFP(v.x, one);
	out.y = ConvertFP(v.y, one);
	out.z = ConvertFP(v.z, one);
	return out;
}

  static inline Color ConvertColor(const PSX::Color& c)
  {
  	Color out = {};
  	out.r = c.r;
  	out.g = c.g;
  	out.b = c.b;
  	out.a = c.a > 0 ? static_cast<unsigned char>(0u) : static_cast<unsigned char>(255u);
  	return out;
  }

  static inline PSX::Color ConvertColor(const Color& c)
  {
  	PSX::Color out = {};
  	out.r = c.r;
  	out.g = c.g;
  	out.b = c.b;
  	out.a = (c.a == 0) ? 1 : 0;
  	return out;
  }

static inline PSX::Stars ConvertStars(const Stars& stars)
{
    PSX::Stars out = {};
    out.numStars = stars.numStars;
    out.spread = stars.spread ? 1u : 0u;
    out.seed = stars.seed;
    out.zDepth = stars.zDepth;
    return out;
}

static inline Stars ConvertStars(const PSX::Stars& stars)
{
    Stars out = {};
    out.numStars = stars.numStars;
    out.spread = stars.spread == 1;
    out.seed = stars.seed;
    out.zDepth = stars.zDepth;
    return out;
}
